#ifndef __il_h__
#define __il_h__

#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <math.h>
#include <assert.h>

#include "context.h"

/*
 * This header file defines the classes used in the 'intermediate language', which is used for type checking
 * and for evaluation. This is different from the abstract syntax tree (AST), which is generated by the
 * parser and must be translated into AST first, using the TranslationVisitor.
*/

#define SAME_SENSITIVITY(a,b) ((isinf(a) && isinf(b)) || (((a)<(b)+0.001) && ((a)>(b)-0.001)))

class ASTVisitor;

/* === BASIC CLASSES ============================================================================================= */

/* ASTBase: The base class of all nodes in an AST tree that can be connected to something in the original source code
  (expressions and types). The SourceContext contains the file name, line number, position, etc., which we
  may want to display if there is an error. */

class ASTBase
{
protected:
  SourceContext *context;
  ASTBase *parent;
  int tag;

public:
  ASTBase(SourceContext *context, int tagArg = 0)
    { this->context = context; this->parent = NULL; this->tag = tagArg; };

  SourceContext *getContext() { return context; };
  virtual void accept(ASTVisitor *worker) = 0;
  virtual bool replace(int tagToReplace, ASTBase *replacement) = 0;
  virtual ASTBase *clone() = 0;
  void setParent(ASTBase *newParent) { parent = newParent; }
  ASTBase *getParent() { return parent; }
  virtual bool isStatement() { return false; }
  virtual bool isVariable() { return false; }
  void setTag(int t) { tag = t; }
  int getTag() { return tag; }
  virtual ASTBase *findByTag(int tag) { return NULL; }
  virtual bool isTrivial() { return false; }
};

enum typeCode { TYPE_INT, TYPE_BOOL, TYPE_REAL, TYPE_KEYPAIR, TYPE_PUBKEY };

/* ASTStatement: A statement */

class ASTStatement : public ASTBase
{
protected:
  ASTStatement *next;

public:
  ASTStatement(SourceContext *context, int tagArg = 0) : ASTBase(context, tagArg) { next = NULL; }
  virtual ASTStatement *clone() { assert(false); return NULL; };
  virtual ASTStatement *cloneWithoutSuccessors() { assert(false); return NULL; };
  virtual void accept(ASTVisitor *worker);
  virtual bool isStatement() { return true; }
  virtual bool isForLoop() { return false; }
  virtual bool isSplitStatement() { return false; }
  ASTStatement *getNext() { return next; }
  void setNext(ASTStatement *newNext) { next = newNext; }
  void appendStatement(ASTStatement *item) { if (next == NULL) next = item; else next->appendStatement(item); }
};

enum encryptionType { ENC_PLAINTEXT, ENC_AHE, ENC_FHE, ENC_UNKNOWN };

class ASTType
{
protected:
  const static int MAX_ARRAY_DEPTH = 10;

  int sensitivity;
  bool monotonic;
  long long minValue;
  long long maxValue;
  typeCode theType;
  int arrayDim[MAX_ARRAY_DEPTH];
  int arrayDepth;
  encryptionType encType;

  bool mustBeEncrypted;
  bool mustBeFHE;

public:
  const static int INF = -1, UNKNOWN = -2;

  ASTType(typeCode whichTypeArg, long long minValueArg, long long maxValueArg, int sensitivityArg = UNKNOWN, bool monotonicArg = false) {
    theType = whichTypeArg; sensitivity = sensitivityArg; monotonic = monotonicArg; minValue = minValueArg, maxValue = maxValueArg;
    arrayDepth = 0; mustBeEncrypted = false; mustBeFHE = false; encType = ENC_PLAINTEXT;
  }
  void addArrayDim(int dim) { assert(arrayDepth < MAX_ARRAY_DEPTH); arrayDim[arrayDepth++] = dim; }
  ASTType *clone() {
    ASTType *result = new ASTType(theType, minValue, maxValue, sensitivity, monotonic);
    for (int i=0; i<arrayDepth; i++) result->addArrayDim(arrayDim[i]);
    result->setMustBeEncrypted(mustBeEncrypted);
    result->setEncryptionType(encType);
    result->setMustBeFHE(mustBeFHE);
    return result;
  };
  void setSensitivity(int sensitivityArg) { sensitivity = sensitivityArg; }
  void setMonotonic(bool monotonicArg) { monotonic = monotonicArg; }
  void setMinValue(long long minValueArg) { minValue = minValueArg; }
  void setMaxValue(long long maxValueArg) { maxValue = maxValueArg; }
  void setMustBeEncrypted(bool arg) { mustBeEncrypted = arg; }
  void setEncryptionType(encryptionType arg) { encType = arg; }
  encryptionType getEncryptionType() { return encType; }
  void setMustBeFHE(bool arg) { mustBeFHE = arg; }
  bool getMustBeEncrypted() { return mustBeEncrypted; }
  bool getMustBeFHE() { return mustBeFHE; }
  long long getMinValue() { return minValue; }
  long long getMaxValue() { return maxValue; }
  int getSensitivity() { return sensitivity; }
  bool isMonotonic() { return monotonic; }
  typeCode whichType() { return theType; }
  int getArrayDepth() { return arrayDepth; }
  int getArrayDim(int level) { assert((0<=level) && (level<arrayDepth)); return arrayDim[level]; }
  void removeArrayDim() { assert(arrayDepth>0); arrayDepth --; }
};

enum vignetteLocation { LOC_USER, LOC_COMMITTEE, LOC_AGGREGATOR, LOC_UNSPECIFIED };

class ASTVignette : public ASTBase
{
protected:
  ASTVignette *next;
  ASTStatement *statements;
  bool isParallel;
  char *loopVariable;
  unsigned int fromVal;
  unsigned int toVal;
  vignetteLocation location;

public:
  ASTVignette(ASTStatement *statementsArg, SourceContext *context, vignetteLocation locArg = LOC_UNSPECIFIED, int tagArg = 0) : ASTBase(context, tagArg) { next = NULL; statements = statementsArg; isParallel = false; loopVariable = NULL; fromVal = 0; toVal = 0; location = locArg; }
  virtual ASTVignette *cloneWithoutSuccessors() {
    ASTVignette *result = new ASTVignette(statements->clone(), context ? context->clone() : NULL, location, tag);
    if (isParallel)
      result->makeParallel(loopVariable, fromVal, toVal);
    return result;
  };
  void setLocation(vignetteLocation locArg) { location = locArg; }
  vignetteLocation getLocation() { return location; }
  virtual ASTVignette *clone() { ASTVignette *result = cloneWithoutSuccessors(); if (next) result->setNext(next->clone()); return result; };
  ASTStatement *getStatements() { return statements; }
  void setStatements(ASTStatement *statementsArg) { statements = statementsArg; }
  virtual void accept(ASTVisitor *worker);
  ASTVignette *getNext() { return next; }
  const char *getLoopVariable() { return loopVariable; }
  unsigned int getFromVal() { return fromVal; }
  unsigned int getToVal() { return toVal; }
  bool parallel() { return isParallel; }
  void makeParallel(const char *loopVariableArg, unsigned int fromValArg, unsigned int toValArg)
    { loopVariable = (char*)malloc(strlen(loopVariableArg)+1); strcpy(loopVariable, loopVariableArg); isParallel = true; fromVal = fromValArg; toVal = toValArg; }
  void setNext(ASTVignette *newNext) { next = newNext; }
  void appendVignette(ASTVignette *item) { if (next == NULL) next = item; else next->appendVignette(item); }
  void removeLastVignette() { if (next) { if (!(next->next)) next = NULL; else next->removeLastVignette(); } }
  void appendStatement(ASTStatement *item) { if (statements == NULL) statements = item; else statements->appendStatement(item); }
  virtual bool replace(int tagToReplace, ASTBase *replacement) {
    if (statements->getTag() == tagToReplace) { ((ASTStatement*)replacement)->appendStatement(statements->getNext()); statements = (ASTStatement*) replacement; return true; }
    if (next && next->getTag() == tagToReplace) { ((ASTVignette*)replacement)->appendVignette(next->getNext()); next = (ASTVignette*) replacement; return true; }
    return statements->replace(tagToReplace, replacement) || (next && next->replace(tagToReplace, replacement));
  }
  virtual ASTBase *findByTag(int tagToFind) {
    if (getTag() == tagToFind)
      return this;
    ASTBase *s = statements->findByTag(tagToFind);
    ASTBase *n = next ? next->findByTag(tagToFind) : NULL;
    return s ? s : (n ? n : NULL);
  }
};

/* ASTExpression: The base class of all expression nodes. Expressions may be typechecked, cloned, displayed, and
   evaluated. Evaluation happens by calling 'evalaute' or 'applyTo'. */

class ASTExpression : public ASTBase
{
protected:
  ASTType *type;

public:
  ASTExpression(SourceContext *context, int tagArg, ASTType *typeArg) : ASTBase(context, tagArg) { type = typeArg; };
  virtual ASTExpression *clone() { assert(false); return NULL; };
  void showMessage(const char *str);
  virtual void accept(ASTVisitor *worker);
  virtual bool equals(ASTExpression *peer)
    { assert(false); return false; };
  virtual bool needsParentheses()
    { return false; };
  ASTType *getType() { return type; }
  void setType(ASTType *newType) { type = newType; }
};

/* ASTConstExpression: The base class for constant expressions */

class ASTConstExpression : public ASTExpression
{
public:
  ASTConstExpression(SourceContext *context, int tagArg = 0, ASTType *typeArg = NULL) : ASTExpression(context, tagArg, typeArg) {};
  virtual void accept(ASTVisitor *worker);
  virtual bool replace(int tagToReplace, ASTBase *replacement) { return false; };
  virtual ASTBase *findByTag(int tagToFind) { if (getTag() == tagToFind) return this; return NULL; }
};

/* ASTConstInt: A numeric constant. */

class ASTConstInt : public ASTConstExpression
{
protected:
  int value;

public:
  ASTConstInt(int value, SourceContext *context = NULL, int tagArg = 0) : ASTConstExpression(context, tagArg) { this->value = value; };
  int getValue()
    { return value; };
  virtual ASTConstInt *clone()
    { return new ASTConstInt(value, context ? context->clone() : NULL, tag); };
  virtual void accept(ASTVisitor *worker);
  virtual bool replace(int tagToReplace, ASTBase *replacement) { return false; };
  virtual ASTBase *findByTag(int tagToFind) { if (getTag() == tagToFind) return this; return NULL; }
  virtual bool isTrivial() { return true; }
};

class ASTConstReal : public ASTConstExpression
{
protected:
  double value;

public:
  ASTConstReal(double value, SourceContext *context = NULL, int tagArg = 0) : ASTConstExpression(context, tagArg) { this->value = value; };
  double getValue()
    { return value; };
  virtual ASTConstReal *clone()
    { return new ASTConstReal(value, context ? context->clone() : NULL, tag); };
  virtual void accept(ASTVisitor *worker);
  virtual bool replace(int tagToReplace, ASTBase *replacement) { return false; };
  virtual ASTBase *findByTag(int tagToFind) { if (getTag() == tagToFind) return this; return NULL; }
  virtual bool isTrivial() { return true; }
};

/* ASTConstBool: A boolean constant. */

class ASTConstBool : public ASTExpression
{
protected:
  bool value;

public:
  ASTConstBool(bool value, SourceContext *context = NULL, int tagArg = 0, ASTType *typeArg = NULL) : ASTExpression(context, tagArg, typeArg)
    { this->value = value; };
  bool getValue()
    { return value; };
  virtual ASTExpression *clone()
    { return new ASTConstBool(value, context ? context->clone() : NULL, tag, type ? type->clone() : NULL); };
  virtual void accept(ASTVisitor *worker);
  virtual bool replace(int tagToReplace, ASTBase *replacement) { return false; };
  virtual ASTBase *findByTag(int tagToFind) { if (getTag() == tagToFind) return this; return NULL; }
  virtual bool isTrivial() { return true; }
};

/* ASTExpressionStatement: A statement that evaluates an expression */

class ASTExpressionStatement : public ASTStatement
{
protected:
  ASTExpression *expr;

public:
  ASTExpressionStatement(ASTExpression *exprArg, SourceContext *context = NULL, int tagArg = 0) : ASTStatement(context, tagArg)
    { this->expr = exprArg; exprArg->setParent(this); }
  ASTExpression *getExpression() { return expr; }
  virtual ASTExpressionStatement *cloneWithoutSuccessors()
    { return new ASTExpressionStatement(expr->clone(), context ? context->clone() : NULL, tag); };
  virtual ASTExpressionStatement *clone()
    { ASTExpressionStatement *result = cloneWithoutSuccessors(); if (next) result->setNext(next->clone()); return result; };
  virtual void accept(ASTVisitor *worker);
  virtual bool replace(int tagToReplace, ASTBase *replacement) {
    if (next && next->getTag() == tagToReplace) { ((ASTStatement*)replacement)->appendStatement(next->getNext()); next = (ASTStatement*) replacement; return true; }
    if (expr->getTag() == tagToReplace) { expr = (ASTExpression*)replacement; return true; }
    return expr->replace(tagToReplace, replacement) || (next && next->replace(tagToReplace, replacement));
  }
  virtual ASTBase *findByTag(int tagToFind) {
    if (getTag() == tagToFind)
      return this;
    ASTBase *l = expr->findByTag(tagToFind);
    ASTBase *n = next ? next->findByTag(tagToFind) : NULL;
    return l ? l : (n ? n : NULL);
  }
  virtual bool isTrivial() { return expr->isTrivial(); }
};

class ASTSplitStatement : public ASTStatement
{
public:
  ASTSplitStatement(SourceContext *context = NULL, int tagArg = 0) : ASTStatement(context, tagArg) { }
  virtual ASTSplitStatement *cloneWithoutSuccessors()
    { return new ASTSplitStatement(context ? context->clone() : NULL, tag); };
  virtual ASTSplitStatement *clone()
    { ASTSplitStatement *result = cloneWithoutSuccessors(); if (next) result->setNext(next->clone()); return result; };
  virtual void accept(ASTVisitor *worker);
  virtual bool isSplitStatement() { return true; }
  virtual bool replace(int tagToReplace, ASTBase *replacement) {
    if (next && next->getTag() == tagToReplace) { ((ASTStatement*)replacement)->appendStatement(next->getNext()); next = (ASTStatement*) replacement; return true; }
    return (next && next->replace(tagToReplace, replacement));
  }
  virtual ASTBase *findByTag(int tagToFind) {
    if (getTag() == tagToFind)
      return this;
    ASTBase *n = next ? next->findByTag(tagToFind) : NULL;
    return n ? n : NULL;
  }
};

/* ASTForStatement: A for loop */

class ASTForStatement : public ASTStatement
{
protected:
  char *loopVariable;
  unsigned int fromVal;
  unsigned int toVal;
  ASTStatement *body;

public:
  ASTForStatement(const char *loopVariableArg, unsigned int fromValArg, unsigned int toValArg, ASTStatement *bodyArg, SourceContext *context = NULL, int tagArg = 0) : ASTStatement(context, tagArg)
    { this->loopVariable = (char*)malloc(strlen(loopVariableArg)+1); strcpy(this->loopVariable, loopVariableArg); this->fromVal = fromValArg; this->toVal = toValArg; this->body = bodyArg; bodyArg->setParent(this); }
  const char *getLoopVariable() { return loopVariable; }
  unsigned int getFromVal() { return fromVal; }
  unsigned int getToVal() { return toVal; }
  ASTStatement *getBody() { return body; }
  virtual bool isForLoop() { return true; }
  virtual ASTForStatement *cloneWithoutSuccessors()
    { return new ASTForStatement(loopVariable, fromVal, toVal, body->clone(), context ? context->clone() : NULL, tag); };
  virtual ASTForStatement *clone()
    { ASTForStatement *result = cloneWithoutSuccessors(); if (next) result->setNext(next->clone()); return result; };
  virtual void accept(ASTVisitor *worker);
  virtual bool replace(int tagToReplace, ASTBase *replacement) {
    if (body->getTag() == tagToReplace) { ((ASTStatement*)replacement)->appendStatement(body->getNext()); body = (ASTStatement*)replacement; return true; }
    if (next && next->getTag() == tagToReplace) { ((ASTStatement*)replacement)->appendStatement(next->getNext()); next = (ASTStatement*) replacement; return true; }
    return body->replace(tagToReplace, replacement) || (next && next->replace(tagToReplace, replacement));
  }
  virtual ASTBase *findByTag(int tagToFind) {
    if (getTag() == tagToFind)
      return this;
    ASTBase *l = body->findByTag(tagToFind);
    ASTBase *n = next ? next->findByTag(tagToFind) : NULL;
    return l ? l : (n ? n : NULL);
  }
};

class ASTIfThenElseStatement : public ASTStatement
{
  ASTExpression *expr;
  ASTStatement *thenBranch;
  ASTStatement *elseBranch;

public:
  ASTIfThenElseStatement(ASTExpression *expr, ASTStatement *thenBranch, ASTStatement *elseBranch, SourceContext *context = NULL, int tagArg = 0) : ASTStatement(context, tagArg)
    { this->expr = expr; this->thenBranch = thenBranch; this->elseBranch = elseBranch; expr->setParent(this); thenBranch->setParent(this); if (elseBranch) elseBranch->setParent(this); };
  ASTExpression *getExpr() { return expr; };
  ASTStatement *getThenBranch() { return thenBranch; };
  ASTStatement *getElseBranch() { return elseBranch; };
  virtual ASTIfThenElseStatement *cloneWithoutSuccessors()
    { return new ASTIfThenElseStatement(expr->clone(), thenBranch->clone(), elseBranch ? elseBranch->clone() : NULL, context ? context->clone() : NULL, tag); };
  virtual ASTIfThenElseStatement *clone()
    { ASTIfThenElseStatement *result = cloneWithoutSuccessors(); if (next) result->setNext(next->clone()); return result; };
  virtual void accept(ASTVisitor *worker);
  virtual bool replace(int tagToReplace, ASTBase *replacement) {
    if (expr->getTag() == tagToReplace) { expr = (ASTExpression*)replacement; return true; }
    if (thenBranch->getTag() == tagToReplace) { thenBranch = (ASTStatement*)replacement; return true; }
    if (elseBranch && (elseBranch->getTag() == tagToReplace)) { elseBranch = (ASTStatement*)replacement; return true; }
    if (next && next->getTag() == tagToReplace) { ((ASTStatement*)replacement)->appendStatement(next->getNext()); next = (ASTStatement*) replacement; return true; }
    return expr->replace(tagToReplace, replacement) || thenBranch->replace(tagToReplace, replacement) || (elseBranch && elseBranch->replace(tagToReplace, replacement)) || (next && next->replace(tagToReplace, replacement));
  }
  virtual ASTBase *findByTag(int tagToFind) {
    if (getTag() == tagToFind)
      return this;
    ASTBase *ex = expr->findByTag(tagToFind), *th = thenBranch->findByTag(tagToFind), *el = elseBranch ? elseBranch->findByTag(tagToFind) : NULL;
    ASTBase *n = next ? next->findByTag(tagToFind) : NULL;
    return ex ? ex : (th ? th : (el ? el : (n ? n : NULL)));
  }
  virtual bool isTrivial() { return thenBranch->isTrivial() && (!elseBranch || elseBranch->isTrivial()); }
};

/* === EXPRESSIONS =============================================================================================== */

/* ASTVariable: A variable */

class ASTVariable : public ASTExpression
{
  char *name;
  ASTExpression *index[10];
  int numIndexes;

public:
  ASTVariable(const char *nameArg, SourceContext *context = NULL, int tagArg = 0, ASTType *typeArg = NULL) : ASTExpression(context, tagArg, typeArg)
    { setName(nameArg); numIndexes = 0; }
  virtual bool isVariable()
    { return true; };
  const char *getName()
    { return name; };
  void setName(const char *nameArg)
    { this->name = (char*) malloc(strlen(nameArg)+1); strcpy(this->name, nameArg); };
  int getNumIndexes()
    { return numIndexes; }
  ASTExpression *getIndex(int idx)
    { return index[idx]; }
  void addIndex(ASTExpression *indexArg)
    { assert(numIndexes < 10); index[numIndexes++] = indexArg; }
  void setIndex(int i, ASTExpression *indexArg) 
    { assert(i < numIndexes); index[i] = indexArg; }
  void stripIndex()
    { numIndexes --; }
  virtual ASTVariable *clone()
    { ASTVariable *var = new ASTVariable(name, context ? context->clone() : NULL, tag, type ? type->clone() : NULL); for (int i=0; i<numIndexes; i++) var->addIndex(index[i]->clone()); return var; };
  virtual void accept(ASTVisitor *worker);
  virtual bool replace(int tagToReplace, ASTBase *replacement) {
    for (int i=0; i<numIndexes; i++) {
      if (index[i]->getTag() == tagToReplace) { index[i] = (ASTExpression*)replacement; return true; }
      if (index[i]->replace(tagToReplace, replacement)) return true;
    }
    return false;
  };
  virtual ASTBase *findByTag(int tagToFind) {
    if (getTag() == tagToFind)
      return this;
    for (int i=0; i<numIndexes; i++) {
      ASTBase *r = index[i]->findByTag(tagToFind);
      if (r)
        return r;
    }
    return NULL;
  }
  virtual bool isTrivial() { return true; }
};

/* ASTInfixOpExpression: Used for functions like addition or multiplication that take two arguments */

class ASTInfixOpExpression : public ASTExpression
{
protected:
  ASTExpression *left;
  ASTExpression *right;
  const char *op;

public:
  ASTInfixOpExpression(ASTExpression *left, const char *op, ASTExpression *right, SourceContext *context = NULL, int tagArg = 0, ASTType *typeArg = NULL) : ASTExpression(context, tagArg, typeArg)
    { this->left = left; this->op = op; this->right = right; left->setParent(this); right->setParent(this); }
  ASTExpression *getLeftExpression() { return left; };
  ASTExpression *getRightExpression() { return right; };
  const char *getOp() { return op; };
  ASTInfixOpExpression *clone()
    { return new ASTInfixOpExpression(left->clone(), op, right->clone(), context ? context->clone() : NULL, tag, type ? type->clone() : NULL); };
  virtual void accept(ASTVisitor *worker);
  virtual bool replace(int tagToReplace, ASTBase *replacement) {
    if (left->getTag() == tagToReplace) { left = (ASTExpression*)replacement; return true; }
    if (right->getTag() == tagToReplace) { right = (ASTExpression*)replacement; return true; }
    return left->replace(tagToReplace, replacement) || right->replace(tagToReplace, replacement);
  }
  virtual ASTBase *findByTag(int tagToFind) {
    if (getTag() == tagToFind)
      return this;
    ASTBase *l = left->findByTag(tagToFind), *r = right->findByTag(tagToFind);
    return l ? l : (r ? r : NULL);
  }
  virtual bool isTrivial() { return true; }
};

/* ASTUnaryExpression: A base class for many unary operators */

class ASTUnaryExpression : public ASTExpression
{
protected:
  ASTExpression *innerExp;

public:
  ASTUnaryExpression(ASTExpression *innerExp, SourceContext *context, int tagArg = 0, ASTType *typeArg = NULL) : ASTExpression(context, tagArg, typeArg)
    { this->innerExp = innerExp; innerExp->setParent(this); }
  ASTExpression *getInnerExp() { return innerExp; };
  virtual void accept(ASTVisitor *worker);
  ASTUnaryExpression *clone()
    { return new ASTUnaryExpression(innerExp->clone(), context ? context->clone() : NULL, tag, type ? type->clone() : NULL); };
  virtual bool replace(int tagToReplace, ASTBase *replacement) {
    if (innerExp->getTag() == tagToReplace) { innerExp = (ASTExpression*)replacement; return true; }
    return innerExp->replace(tagToReplace, replacement);
  }
  virtual ASTBase *findByTag(int tagToFind) {
    if (getTag() == tagToFind)
      return this;
    ASTBase *ie = innerExp->findByTag(tagToFind);
    return ie ? ie : NULL;
  }
  virtual bool isTrivial() { return true; }
};

class ASTArrayExpression : public ASTExpression
{
protected:
  const static int MAX_ELEMENTS = 100;
  int numElements;
  ASTExpression *element[MAX_ELEMENTS];

public:
  ASTArrayExpression(SourceContext *context, int tagArg = 0, ASTType *typeArg = NULL) : ASTExpression(context, tagArg, typeArg)
    { numElements = 0; }
  int getNumElements() { return numElements; }
  ASTExpression *getElement(int idx) { assert((idx>=0) && (idx<numElements)); return element[idx]; };
  void addElement(ASTExpression *newElement) { assert(numElements < MAX_ELEMENTS); element[numElements++] = newElement; newElement->setParent(this); }
  virtual void accept(ASTVisitor *worker);
  ASTArrayExpression *clone() {
    ASTArrayExpression *result = new ASTArrayExpression(context ? context->clone() : NULL, tag, type ? type->clone() : NULL);
    for (int i=0; i<numElements; i++)
      result->addElement(element[i]->clone());
    return result;
  };
  virtual bool replace(int tagToReplace, ASTBase *replacement) {
    for (int i=0; i<numElements; i++)
      if (element[i]->getTag() == tagToReplace) { element[i] = (ASTExpression*)replacement; return true; }
    bool result = false;
    for (int i=0; i<numElements; i++)
      result |= element[i]->replace(tagToReplace, replacement);
    return result;
  }
  virtual ASTBase *findByTag(int tagToFind) {
    for (int i=0; i<numElements; i++) {
      ASTBase *res = element[i]->findByTag(tagToFind);
      if (res)
        return res;
    }
    return NULL;
  }
  virtual bool isTrivial() { return true; }
};

/* ASTLetBinding: A let binding */

class ASTLetBinding : public ASTStatement
{
protected:
  ASTVariable *varToBind;
  ASTExpression *rightHandExp;
  ASTType *type;

public:
  ASTLetBinding(ASTVariable *varToBind, ASTExpression *rightHandExp, ASTType *typeArg = NULL, SourceContext *context = NULL, int tagArg = 0) : ASTStatement(context, tagArg)
    { this->rightHandExp = rightHandExp; this->varToBind = varToBind; this->type = typeArg; rightHandExp->setParent(this); varToBind->setParent(this); }
  ASTVariable *getVarToBind() { return varToBind; }
  ASTExpression *getRightHandExp() { return rightHandExp; };
  ASTType *getType() { return type; }
  void setType(ASTType *newType) { type = newType; }
  virtual ASTLetBinding *cloneWithoutSuccessors()
    { return new ASTLetBinding(varToBind->clone(), rightHandExp->clone(), type ? type->clone() : NULL, context ? context->clone() : NULL, tag); };
  virtual ASTLetBinding *clone()
    { ASTLetBinding *result = cloneWithoutSuccessors(); if (next) result->setNext(next->clone()); return result; };
  virtual void accept(ASTVisitor *worker);
  virtual bool replace(int tagToReplace, ASTBase *replacement) {
    if (rightHandExp->getTag() == tagToReplace) { rightHandExp = (ASTExpression*)replacement; return true; }
    if (varToBind->getTag() == tagToReplace) { varToBind = (ASTVariable*)replacement; return true; }
    if (next && next->getTag() == tagToReplace) { ((ASTStatement*)replacement)->appendStatement(next->getNext()); next = (ASTStatement*) replacement; return true; }
    return rightHandExp->replace(tagToReplace, replacement) || varToBind->replace(tagToReplace, replacement) || (next && next->replace(tagToReplace, replacement));
  }
  virtual ASTBase *findByTag(int tagToFind) {
    if (getTag() == tagToFind)
      return this;
    ASTBase *ie = rightHandExp->findByTag(tagToFind);
    ASTBase *vb = varToBind->findByTag(tagToFind);
    ASTBase *n = next ? next->findByTag(tagToFind) : NULL;
    return ie ? ie : (vb ? vb : (n ? n : NULL));
  }
  virtual bool isTrivial() { return rightHandExp->isTrivial(); }
};

/* ASTFunctionExpression: A function call */

class ASTFunctionExpression : public ASTExpression
{
protected:
  char *functionName;
  int numArgs;
  ASTExpression *arg[10];

public:
  ASTFunctionExpression(const char *functionNameArg, SourceContext *context = NULL, int tagArg = 0, ASTType *typeArg = NULL) : ASTExpression(context, tagArg, typeArg)
    { setFunctionName(functionNameArg); this->numArgs = 0; }
  void addArgument(ASTExpression *argArg)
    { assert(numArgs < 10); arg[numArgs++] = argArg; argArg->setParent(this); }
  void removeArguments()
    { numArgs = 0; }
  const char *getFunctionName() { return functionName; };
  void setFunctionName(const char *newName) { functionName = (char*)malloc(strlen(newName)+1); strcpy(functionName, newName); };
  int getNumArgs() { return numArgs; }
  ASTExpression *getArg(int idx) { return arg[idx]; };
  virtual ASTExpression *clone()
    { ASTFunctionExpression *c = new ASTFunctionExpression(functionName, context ? context->clone() : NULL, tag, type ? type->clone() : NULL); for (int i=0; i<numArgs; i++) c->addArgument(arg[i]->clone()); return c; };
  virtual void accept(ASTVisitor *worker);
  virtual bool replace(int tagToReplace, ASTBase *replacement) {
    for (int i=0; i<numArgs; i++) {
      if (arg[i]->getTag() == tagToReplace) { arg[i] = (ASTExpression*)replacement; return true; }
      if (arg[i]->replace(tagToReplace, replacement)) return true;
    }
    return false;
  }
  virtual ASTBase *findByTag(int tagToFind) {
    if (getTag() == tagToFind)
      return this;
    for (int i=0; i<numArgs; i++) {
      ASTBase *r = arg[i]->findByTag(tagToFind);
      if (r)
        return r;
    }
    return NULL;
  }
};

/* === VISITOR =================================================================================================== */

class ASTVisitor
{
public:
  virtual void visit(ASTBase *peer) { assert(false); };
  virtual void visit(ASTExpression *peer) { assert(false); };
  virtual void visit(ASTVariable *peer) { assert(false); };
  virtual void visit(ASTInfixOpExpression *peer) { assert(false); };
  virtual void visit(ASTUnaryExpression *peer) { assert(false); };
  virtual void visit(ASTLetBinding *peer) { assert(false); };
  virtual void visit(ASTFunctionExpression *peer) { assert(false); };
  virtual void visit(ASTConstExpression *peer) { assert(false); };
  virtual void visit(ASTConstInt *peer) { assert(false); };
  virtual void visit(ASTConstReal *peer) { assert(false); };
  virtual void visit(ASTConstBool *peer) { assert(false); };
  virtual void visit(ASTIfThenElseStatement *peer) { assert(false); };
  virtual void visit(ASTExpressionStatement *peer) { assert(false); };
  virtual void visit(ASTForStatement *peer) { assert(false); };
  virtual void visit(ASTVignette *peer) { assert(false); };
  virtual void visit(ASTArrayExpression *peer) { assert(false); };
  virtual void visit(ASTSplitStatement *peer) { assert(false); };
};

class ASTDFSVisitor : public ASTVisitor
{
protected:
  bool aborted;

public:
  ASTDFSVisitor() : ASTVisitor() { aborted = false; }
  virtual void visit(ASTVariable *peer) { };
  virtual void visit(ASTInfixOpExpression *peer) { if (!aborted) peer->getLeftExpression()->accept(this); if (!aborted) peer->getRightExpression()->accept(this); };
  virtual void visit(ASTLetBinding *peer) { if (!aborted) peer->getRightHandExp()->accept(this); if (!aborted) peer->getVarToBind()->accept(this); if (!aborted && peer->getNext()) peer->getNext()->accept(this); };
  virtual void visit(ASTFunctionExpression *peer) { for (int i=0; i<peer->getNumArgs(); i++) if (!aborted) peer->getArg(i)->accept(this); };
  virtual void visit(ASTConstInt *peer) { };
  virtual void visit(ASTConstReal *peer) { };
  virtual void visit(ASTIfThenElseStatement *peer) { if (!aborted) peer->getExpr()->accept(this); if (!aborted) peer->getThenBranch()->accept(this); if (!aborted && peer->getElseBranch()) peer->getElseBranch()->accept(this); if (!aborted && peer->getNext()) peer->getNext()->accept(this); };
  virtual void visit(ASTForStatement *peer) { if (!aborted) peer->getBody()->accept(this); if (!aborted && peer->getNext()) peer->getNext()->accept(this); };
  virtual void visit(ASTUnaryExpression *peer) { if (!aborted) peer->getInnerExp()->accept(this); };
  virtual void visit(ASTExpressionStatement *peer) { if (!aborted) peer->getExpression()->accept(this); if (!aborted && peer->getNext()) peer->getNext()->accept(this); };
  virtual void visit(ASTVignette *peer) { if (!aborted) peer->getStatements()->accept(this); if (!aborted && peer->getNext()) peer->getNext()->accept(this); };
  virtual void visit(ASTArrayExpression *peer) { for (int i=0; i<peer->getNumElements(); i++) if (!aborted) peer->getElement(i)->accept(this); };
  virtual void visit(ASTSplitStatement *peer) { if (!aborted && peer->getNext()) peer->getNext()->accept(this); };
};

class ASTVariantGenerator : public ASTDFSVisitor
{
  ASTVignette *root;
  const char *name;

public:
  ASTVariantGenerator(ASTVignette *rootArg, const char *nameArg) : ASTDFSVisitor() { root = rootArg; name = nameArg; }
  virtual void visit(ASTFunctionExpression *peer);
  virtual void visit(ASTForStatement *peer);
};

class ASTFullyExpandedChecker : public ASTDFSVisitor
{
  bool fullyExpanded;

public:
  ASTFullyExpandedChecker() : ASTDFSVisitor() { fullyExpanded = true; }
  virtual void visit(ASTFunctionExpression *peer) {
    if (!strcmp(peer->getFunctionName(), "sum") || !strcmp(peer->getFunctionName(), "em") || !strcmp(peer->getFunctionName(), "emSecret") || !strcmp(peer->getFunctionName(), "min") || !strcmp(peer->getFunctionName(), "max") || !strcmp(peer->getFunctionName(), "argmax"))
      fullyExpanded = false;
    ASTDFSVisitor::visit(peer);
  }
  bool isFullyExpanded() { return fullyExpanded; }
};

class ASTDFSVisitorWithSymbolTable : public ASTDFSVisitor
{
protected:
  const static int MAX_SYMBOLS = 500;
  struct {
    char varName[500];
    ASTType *type;
  } symbolTable[MAX_SYMBOLS];
  int numSymbols;

public:
  ASTDFSVisitorWithSymbolTable() : ASTDFSVisitor() { clearSymbolTable(); }
  void clearSymbolTable() {
    numSymbols = 0;
  }
  void addSymbol(const char *nameArg, ASTType *typeArg) {
    assert(numSymbols < MAX_SYMBOLS);
    strcpy(symbolTable[numSymbols].varName, nameArg);
    symbolTable[numSymbols].type = typeArg;
    numSymbols ++;
  }
  ASTType *findSymbol(const char *name) {
    for (int i=0; i<numSymbols; i++)
      if (!strcmp(symbolTable[i].varName, name))
        return symbolTable[i].type;
    return NULL;
  }
  void deleteSymbol(const char *nameArg) {
    for (int i=0; i<numSymbols; i++) {
      if (!strcmp(symbolTable[i].varName, nameArg)) {
        symbolTable[i] = symbolTable[--numSymbols];
        return;
      }
    }
  }
  void dumpSymbolTable();
};


class ASTInitialTypeInference : public ASTDFSVisitorWithSymbolTable
{
public:
  ASTInitialTypeInference() : ASTDFSVisitorWithSymbolTable() { }
  virtual void visit(ASTVariable *peer);
  virtual void visit(ASTInfixOpExpression *peer);
  virtual void visit(ASTUnaryExpression *peer) { ASTDFSVisitor::visit(peer); };
  virtual void visit(ASTLetBinding *peer);
  virtual void visit(ASTFunctionExpression *peer);
  virtual void visit(ASTConstInt *peer);
  virtual void visit(ASTConstReal *peer);
  virtual void visit(ASTConstBool *peer);
  virtual void visit(ASTIfThenElseStatement *peer) { ASTDFSVisitor::visit(peer); };
  virtual void visit(ASTExpressionStatement *peer) { ASTDFSVisitor::visit(peer); };
  virtual void visit(ASTForStatement *peer);
  virtual void visit(ASTVignette *peer);
  virtual void visit(ASTArrayExpression *peer);
};

class ASTDataParallelChecker : public ASTDFSVisitor
{
  const static int MAX_SYMBOLS = 500;
  struct {
    char varName[500];
    bool usedOnLHS;
  } symbolTable[MAX_SYMBOLS];
  int numSymbols;
  bool isDataParallel;

  int findVariable(const char *n) {
    for (int i=0; i<numSymbols; i++)
      if (!strcmp(symbolTable[i].varName, n))
        return i;
    return -1;
  }

public:
  ASTDataParallelChecker() : ASTDFSVisitor() { numSymbols = 0; isDataParallel = true; }
  void assertSide(const char *varName, bool usedOnLHS) {
    int idx = findVariable(varName);
    if (idx >= 0) {
      if (symbolTable[idx].usedOnLHS != usedOnLHS)
        isDataParallel = false;
    } else {
      assert(numSymbols < MAX_SYMBOLS);
      idx = numSymbols ++;
      strcpy(symbolTable[idx].varName, varName);
      symbolTable[idx].usedOnLHS = usedOnLHS;
    }
  }
  virtual void visit(ASTLetBinding *peer) { 
    assertSide(peer->getVarToBind()->getName(), true);
    peer->getRightHandExp()->accept(this);
  }
  virtual void visit(ASTVariable *peer) { 
    assertSide(peer->getName(), false);
  }
  bool dataParallel() { return isDataParallel; }
};

class ASTVariablePrefixFinder : public ASTDFSVisitor
{
  bool found;
  const char *name;

public:
  ASTVariablePrefixFinder(const char *nameArg) : ASTDFSVisitor() { name = nameArg; found = false; }
  virtual void visit(ASTLetBinding *peer) { if (!strncmp(peer->getVarToBind()->getName(), name, strlen(name))) found = true; ASTDFSVisitor::visit(peer); }
  bool isFound() { return found; }
};

class ASTRenameVariableVisitor : public ASTDFSVisitor
{
  const char *oldName, *newName;

public:
  ASTRenameVariableVisitor(const char *oldNameArg, const char *newNameArg) : ASTDFSVisitor() { oldName = oldNameArg; newName = newNameArg; }
  virtual void visit(ASTVariable *peer) { if (!strcmp(peer->getName(), oldName)) peer->setName(newName);}
};

class ASTVariableSubstitutionVisitor : public ASTDFSVisitor
{
  const char *varName;
  ASTExpression *replacement;

public:
  ASTVariableSubstitutionVisitor(const char *varNameArg, ASTExpression *replacementArg) : ASTDFSVisitor() { 
    varName = varNameArg; replacement = replacementArg; 
  }
  virtual void visit(ASTVariable *peer) { 
    if (!strcmp(peer->getName(), varName)) {
      ASTBase *parent = peer->getParent();
      assert(parent);
      parent->replace(peer->getTag(), replacement->clone());
    } else {
      for (int i=0; i<peer->getNumIndexes(); i++) {
        if (peer->getIndex(i)->isVariable()) {
          ASTVariable *theIndex = (ASTVariable*)peer->getIndex(i);
          if (!strcmp(theIndex->getName(), varName))
            peer->setIndex(i, replacement->clone());
        } else {
          peer->getIndex(i)->accept(this);
        }
      }
    }
  }
};

class ASTUpgradeVariableToFHEVisitor : public ASTDFSVisitor
{
  const char *name;

public:
  ASTUpgradeVariableToFHEVisitor(const char *nameArg) : ASTDFSVisitor() { name = nameArg; }
  virtual void visit(ASTLetBinding *peer) { if (!strcmp(peer->getVarToBind()->getName(), name)) peer->getType()->setEncryptionType(ENC_FHE); ASTDFSVisitor::visit(peer); }
};

class ASTFunctionFinder : public ASTDFSVisitor
{
  bool found;
  const char *name;

public:
  ASTFunctionFinder(const char *nameArg) : ASTDFSVisitor() { name = nameArg; reset(); }
  void reset() { found = false; }
  virtual void visit(ASTFunctionExpression *peer) { if (!strcmp(peer->getFunctionName(), name)) found = true; ASTDFSVisitor::visit(peer); }
  bool isFound() { return found; }
};

class ASTCryptoFinder : public ASTDFSVisitor
{
  bool foundAHE, foundFHE;

public:
  ASTCryptoFinder() : ASTDFSVisitor() { reset(); }
  void reset() { foundAHE = false; foundFHE = false; }
  virtual void visit(ASTLetBinding *peer) {
    if (peer->getType()->getEncryptionType() == ENC_AHE)
      foundAHE = true;
    if (peer->getType()->getEncryptionType() == ENC_FHE)
      foundFHE = true;
    ASTDFSVisitor::visit(peer);
  }
  bool hasFoundAHE() { return foundAHE; }
  bool hasFoundFHE() { return foundFHE; }
};

class ASTTagger : public ASTDFSVisitor
{
  int nextTag;

public:
  ASTTagger() : ASTDFSVisitor() { nextTag = 1; }
  virtual void visit(ASTVariable *peer) { peer->setTag(nextTag++); ASTDFSVisitor::visit(peer); };
  virtual void visit(ASTInfixOpExpression *peer) { peer->setTag(nextTag++); ASTDFSVisitor::visit(peer); };
  virtual void visit(ASTUnaryExpression *peer) { peer->setTag(nextTag++); ASTDFSVisitor::visit(peer); };
  virtual void visit(ASTLetBinding *peer) { peer->setTag(nextTag++); ASTDFSVisitor::visit(peer); };
  virtual void visit(ASTSplitStatement *peer) { peer->setTag(nextTag++); ASTDFSVisitor::visit(peer); };
  virtual void visit(ASTFunctionExpression *peer) { peer->setTag(nextTag++); ASTDFSVisitor::visit(peer); };
  virtual void visit(ASTConstExpression *peer) { peer->setTag(nextTag++);  };
  virtual void visit(ASTConstInt *peer) { peer->setTag(nextTag++); };
  virtual void visit(ASTConstReal *peer) { peer->setTag(nextTag++); };
  virtual void visit(ASTConstBool *peer) { peer->setTag(nextTag++); };
  virtual void visit(ASTIfThenElseStatement *peer) { peer->setTag(nextTag++); ASTDFSVisitor::visit(peer); };
  virtual void visit(ASTExpressionStatement *peer) { peer->setTag(nextTag++); ASTDFSVisitor::visit(peer); };
  virtual void visit(ASTForStatement *peer) { peer->setTag(nextTag++); ASTDFSVisitor::visit(peer); };
  virtual void visit(ASTVignette *peer) { peer->setTag(nextTag++); ASTDFSVisitor::visit(peer); };
};

class ASTCryptoAnalysis : public ASTDFSVisitorWithSymbolTable
{
  vignetteLocation currentVignetteLocation;
  bool inExpressionThatNeedsFHE;
  bool inExpressionThatMustBeEncrypted;
  ASTVignette *root;

public:
  ASTCryptoAnalysis(ASTVignette *rootArg) : ASTDFSVisitorWithSymbolTable() { reset(rootArg); }
  void reset(ASTVignette *rootArg) { clearSymbolTable(); root = rootArg; currentVignetteLocation = LOC_UNSPECIFIED; inExpressionThatMustBeEncrypted = false; inExpressionThatNeedsFHE = false; }
  virtual void visit(ASTVariable *peer);
  virtual void visit(ASTInfixOpExpression *peer);
  virtual void visit(ASTLetBinding *peer);
  virtual void visit(ASTForStatement *peer);
  virtual void visit(ASTVignette *peer);
  virtual void visit(ASTFunctionExpression *peer);
};

#endif /* defined(__il_h__) */
